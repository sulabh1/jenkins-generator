import { Injectable } from '@nestjs/common';
import { CICDConfig } from '../interfaces/config.interface';
import { CloudProviderService } from './cloud-provider.service';
import { NotificationService } from './notification.service';
import { SecurityService } from './security.service';
import { EnvironmentService } from './environment.service';

@Injectable()
export class JenkinsFileService {
  constructor(
    private readonly cloudProvider: CloudProviderService,
    private readonly notificationService: NotificationService,
    private readonly securityService: SecurityService,
    private readonly environmentService: EnvironmentService,
  ) {}

  generateJenkinsfile(config: CICDConfig): string {
    const { project, cloud, notifications, jenkinsConfig } = config;
    const dockerImageName = `${project.projectName
      .toLowerCase()
      .replace(/\s+/g, '-')}`;
    const dockerImageTag = '${BUILD_NUMBER}';

    const notificationFunctions =
      this.notificationService.generateNotificationScript(notifications);
    const deploymentScript = this.cloudProvider.generateDeploymentScript(
      cloud,
      dockerImageName,
    );
    const credentialsEnv =
      this.cloudProvider.generateCredentialsEnvironmentVariables(cloud);

    // NEW: Generate external services environment variables
    const externalServicesEnv =
      this.environmentService.generateEnvironmentVariablesBlock(
        project.externalServices,
      );

    const jenkinsfile = `// Auto-generated Jenkins Pipeline
// Generated by Jenkins Generator
// Project: ${project.projectName}
// Cloud Provider: ${cloud.provider}
// Generated on: ${new Date().toISOString()}

pipeline {
  agent {
    label '${jenkinsConfig.agentLabel}'
  }

  options {
    timeout(time: ${jenkinsConfig.timeout}, unit: 'MINUTES')
    buildDiscarder(logRotator(numToKeepStr: '10'))
    timestamps()
    disableConcurrentBuilds()
  }

  ${credentialsEnv}
  ${externalServicesEnv}

  stages {
    stage('Checkout') {
      steps {
        script {
          echo "Checking out code from repository..."
          checkout([
            $class: 'GitSCM',
            branches: [[name: '*/${project.branch}']],
            userRemoteConfigs: [[
              url: '${project.repository}',
              credentialsId: 'git-credentials'
            ]]
          ])
          echo "Code checked out successfully"
        }
      }
    }

    stage('Install Dependencies') {
      steps {
        script {
          echo "Installing dependencies..."
          ${project.language === 'javascript' ? 'sh "npm ci"' : 'sh "npm ci"'}
          echo "Dependencies installed successfully"
        }
      }
    }

${
  project.runTests && project.testCommand
    ? this.generateTestStage(project.testCommand, jenkinsConfig.retryCount)
    : ''
}

    stage('Build') {
      steps {
        script {
          echo "Building application..."
          ${
            project.buildCommand
              ? `sh "${project.buildCommand}"`
              : '// No build command specified'
          }
          echo "Build completed successfully"
        }
      }
    }

    stage('Docker Build') {
      steps {
        script {
          echo "Building Docker image..."
          def dockerImage = "${dockerImageName}:${dockerImageTag}"
          
          ${
            project.hasDockerfile
              ? `sh "docker build -t \${dockerImage} -f ${
                  project.dockerfilePath || 'Dockerfile'
                } ."`
              : `error("Dockerfile not found. Please ensure Dockerfile exists in the project.")`
          }
          
          env.DOCKER_IMAGE = dockerImage
          echo "Docker image built: \${dockerImage}"
        }
      }
    }

    stage('Push Docker Image') {
      steps {
        script {
          ${this.generateDockerPushScript(
            cloud,
            dockerImageName,
            dockerImageTag,
          )}
          
          // DOCKER_IMAGE is updated within generateDockerPushScript
          echo "Docker image pushed successfully"
        }
      }
    }

    stage('Deploy to ${cloud.provider.toUpperCase()}') {
      steps {
        script {
          echo "Deploying to ${cloud.provider.toUpperCase()}..."
          
          retry(${jenkinsConfig.retryCount}) {
            sh '''
              ${deploymentScript}
            '''
          }
          
          echo "Deployment to ${cloud.provider.toUpperCase()} completed successfully"
        }
      }
    }

    stage('Health Check') {
      steps {
        script {
          echo "Performing health check..."
          sleep(time: 30, unit: 'SECONDS')
          
          if (fileExists('deployment.env')) {
            def props = readProperties file: 'deployment.env'
            env.DEPLOYED_URL = props['DEPLOYED_URL']
          }
          
          def healthCheckPassed = false
          def maxRetries = 5
          def retryCount = 0
          
          while (!healthCheckPassed && retryCount < maxRetries) {
            try {
              // Functional health check using curl
              sh """
                echo "Checking health at: \${DEPLOYED_URL}${
                  cloud.deploymentConfig.healthCheckPath
                }"
                curl -f \${DEPLOYED_URL}${
                  cloud.deploymentConfig.healthCheckPath
                } || exit 1
              """
              healthCheckPassed = true
              echo "Health check passed"
            } catch (Exception e) {
              retryCount++
              echo "Health check failed. Attempt \${retryCount}/\${maxRetries}"
              sleep(time: 10, unit: 'SECONDS')
            }
          }
          
          if (!healthCheckPassed) {
            error("Health check failed after \${maxRetries} attempts")
          }
        }
      }
    }

    stage('Cleanup') {
      steps {
        script {
          echo "Cleaning up old Docker images..."
          sh """
            docker image prune -f
            docker container prune -f
          """
          echo "Cleanup completed"
        }
      }
    }
  }

  ${this.notificationService.generatePostStageNotifications()}
}

// Notification Functions
${notificationFunctions}
`;

    return jenkinsfile;
  }

  private generateTestStage(testCommand: string, retryCount: number): string {
    return `
    stage('Run Tests') {
      steps {
        script {
          echo "Running tests..."
          retry(${retryCount}) {
            sh "${testCommand}"
          }
          echo "Tests completed successfully"
        }
      }
      post {
        always {
          // Publish test results if available
          junit(testResults: '**/test-results/*.xml', allowEmptyResults: true)
        }
      }
    }
`;
  }

  generateCredentialsSetupGuide(config: CICDConfig): string {
    const { cloud, notifications, project } = config;

    let guide = `
╔════════════════════════════════════════════════════════════════╗
║           JENKINS CREDENTIALS SETUP GUIDE                      ║
╚════════════════════════════════════════════════════════════════╝

Please configure the following credentials in Jenkins:
(Manage Jenkins → Manage Credentials → Global Credentials)

1. GIT CREDENTIALS
   ID: git-credentials
   Type: Username with password
   Scope: Global
   Description: Git repository credentials

2. DOCKER REGISTRY CREDENTIALS
   ID: docker-registry-credentials
   Type: Username with password
   Scope: Global
   Description: Docker Hub or private registry credentials

`;

    switch (cloud.provider) {
      case 'aws': {
        const awsCreds = cloud.credentials as any;
        if (awsCreds.useOIDC) {
          guide += `
3. AWS CREDENTIALS (OIDC)
   - ID: aws-oidc-token
     Type: OpenID Connect Token
     Description: AWS OIDC Token from Federated Identity
   
   - [Setup Required]: Configure AWS Workload Identity Federation with Role ARN: ${awsCreds.oidcRoleArn}
`;
        } else {
          guide += `
3. AWS CREDENTIALS
   - ID: aws-access-key-id
     Type: Secret text
     Secret: ${this.securityService.maskSensitiveData(awsCreds.accessKeyId)}
   
   - ID: aws-secret-access-key
     Type: Secret text
     Secret: [Your AWS Secret Access Key]
`;
        }
        break;
      }

      case 'azure': {
        const azCreds = cloud.credentials as any;
        guide += `
3. AZURE CREDENTIALS
   - ID: azure-subscription-id
     Type: Secret text
     Secret: ${this.securityService.maskSensitiveData(azCreds.subscriptionId)}
   
   - ID: azure-client-id
     Type: Secret text
     Secret: ${this.securityService.maskSensitiveData(azCreds.clientId)}
   
   - ID: azure-tenant-id
     Type: Secret text
     Secret: ${this.securityService.maskSensitiveData(azCreds.tenantId)}
`;
        if (azCreds.useOIDC) {
          guide += `
   - ID: azure-federated-token
     Type: OpenID Connect Token
     Description: Azure Federated Token for Service Principal
`;
        } else {
          guide += `
   - ID: azure-client-secret
     Type: Secret text
     Secret: [Your Azure Client Secret]
`;
        }
        break;
      }

      case 'gcp': {
        const gcpCreds = cloud.credentials as any;
        guide += `
3. GCP CREDENTIALS
   - ID: gcp-project-id
     Type: Secret text
     Secret: ${gcpCreds.projectId}
`;
        if (gcpCreds.useOIDC) {
          guide += `
   - ID: gcp-oidc-token
     Type: OpenID Connect Token
     Description: GCP OIDC Token (Workload Identity Federation)
`;
        } else {
          guide += `
   - ID: gcp-key-file
     Type: Secret file
     File: Upload your GCP service account key JSON file
`;
        }
        break;
      }

      case 'digitalocean':
        guide += `
3. DIGITALOCEAN CREDENTIALS
   - ID: do-api-token
     Type: Secret text
     Secret: [Your DigitalOcean API Token]
`;
        break;
    }

    // NEW: Add external services credentials guide
    if (project.externalServices && project.externalServices.length > 0) {
      guide += this.environmentService.generateCredentialsSetupGuide(
        project.externalServices,
      );
    }

    guide += `
4. NOTIFICATION CREDENTIALS (if applicable)
   Email notifications are configured automatically.
   For webhook-based notifications, ensure the URLs are accessible.

╔════════════════════════════════════════════════════════════════╗
║                    SECURITY REMINDERS                          ║
╚════════════════════════════════════════════════════════════════╝

⚠️  NEVER commit credentials to version control
⚠️  Use Jenkins credential storage for all sensitive data
⚠️  Rotate credentials regularly
⚠️  Use least-privilege access principles
⚠️  Enable audit logging in Jenkins
⚠️  Regularly review and remove unused credentials

`;

    return guide;
  }

  generateReadme(config: CICDConfig): string {
    const { project, cloud } = config;

    let readme = `# ${project.projectName} - CI/CD Pipeline

## Auto-generated CI/CD Configuration

This Jenkins pipeline was automatically generated by Jenkins Generator.

### Project Information
- **Project Name:** ${project.projectName}
- **Project Type:** ${project.projectType}
- **Language:** ${project.language}
- **Repository:** ${project.repository}
- **Branch:** ${project.branch}

### Cloud Deployment
- **Provider:** ${cloud.provider.toUpperCase()}
- **Region:** ${cloud.region}
- **Instance Type:** ${cloud.instanceType}

### Pipeline Stages
1. **Checkout** - Clone repository
2. **Install Dependencies** - Install npm packages
${
  project.runTests ? '3. **Run Tests** - Execute test suite\n' : ''
}4. **Build** - Build application
5. **Docker Build** - Create Docker image
6. **Push Docker Image** - Push to Docker registry
7. **Deploy** - Deploy to ${cloud.provider.toUpperCase()}
8. **Health Check** - Verify deployment
9. **Cleanup** - Remove old images

### Setup Instructions

1. **Install Required Jenkins Plugins:**
   - Docker Pipeline
   - Git
   - Email Extension
   - Pipeline
   - Credentials Binding
   - Blue Ocean (optional, for better UI)

2. **Configure Credentials:**
   See CREDENTIALS_SETUP.md for detailed instructions.

3. **Create Jenkins Pipeline Job:**
   - New Item → Pipeline
   - Configure Git repository
   - Point to Jenkinsfile in repository root
   - Save and run

4. **Verify Deployment:**
   - Monitor pipeline execution
   - Check email notifications
   - Verify application is running in ${cloud.provider.toUpperCase()}
`;

    // NEW: Add external services documentation
    if (project.externalServices && project.externalServices.length > 0) {
      readme += this.environmentService.generateReadmeServicesSection(
        project.externalServices,
      );
    }

    readme += `
### Customization

To modify the pipeline:
1. Edit the Jenkinsfile in your repository root
2. Commit and push changes
3. Jenkins will automatically use the updated pipeline

### Troubleshooting

- **Build Fails:** Check Jenkins console output
- **Deployment Fails:** Verify cloud credentials
- **Docker Issues:** Ensure Docker is installed on Jenkins agent
- **Notification Issues:** Verify webhook URLs and email configuration

### Support

For issues or questions, refer to:
- Jenkins Documentation: https://www.jenkins.io/doc/
- ${cloud.provider.toUpperCase()} Documentation
- Docker Documentation: https://docs.docker.com/

---
Generated on: ${new Date().toISOString()}
`;

    return readme;
  }

  private generateDockerPushScript(
    cloud: any,
    dockerImageName: string,
    dockerImageTag: string,
  ): string {
    const registryMap = {
      aws: '${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com',
      azure: '${ACR_LOGIN_SERVER}',
      gcp: 'gcr.io/${GCP_PROJECT_ID}',
      digitalocean: 'registry.digitalocean.com/${DO_REGISTRY_NAME}',
    };

    const registry = registryMap[cloud.provider] || '${DOCKER_USERNAME}';

    switch (cloud.provider) {
      case 'aws':
        return `
          echo "Pushing Docker image to AWS ECR..."
          sh "aws ecr get-login-password --region \${AWS_REGION} | docker login --username AWS --password-stdin ${registry}"
          sh "docker tag \${DOCKER_IMAGE} ${registry}/${dockerImageName}:\${dockerImageTag}"
          sh "docker push ${registry}/${dockerImageName}:\${dockerImageTag}"
          env.DOCKER_IMAGE = "${registry}/${dockerImageName}:\${dockerImageTag}"
        `;
      case 'azure':
        return `
          echo "Pushing Docker image to Azure ACR..."
          withCredentials([
            usernamePassword(
              credentialsId: 'azure-acr-credentials',
              usernameVariable: 'ACR_USERNAME',
              passwordVariable: 'ACR_PASSWORD'
            )
          ]) {
            sh "echo \${ACR_PASSWORD} | docker login ${registry} -u \${ACR_USERNAME} --password-stdin"
            sh "docker tag \${DOCKER_IMAGE} ${registry}/${dockerImageName}:\${dockerImageTag}"
            sh "docker push ${registry}/${dockerImageName}:\${dockerImageTag}"
            env.DOCKER_IMAGE = "${registry}/${dockerImageName}:\${dockerImageTag}"
          }
        `;
      case 'gcp':
        return `
          echo "Pushing Docker image to GCP Container Registry..."
          sh "gcloud auth configure-docker --quiet"
          sh "docker tag \${DOCKER_IMAGE} ${registry}/${dockerImageName}:\${dockerImageTag}"
          sh "docker push ${registry}/${dockerImageName}:\${dockerImageTag}"
          env.DOCKER_IMAGE = "${registry}/${dockerImageName}:\${dockerImageTag}"
        `;
      case 'digitalocean':
        return `
          echo "Pushing Docker image to DigitalOcean Registry..."
          sh "doctl auth init --access-token \${DO_API_TOKEN}"
          sh "doctl registry login --expiry-seconds 600"
          sh "docker tag \${DOCKER_IMAGE} ${registry}/${dockerImageName}:\${dockerImageTag}"
          sh "docker push ${registry}/${dockerImageName}:\${dockerImageTag}"
          env.DOCKER_IMAGE = "${registry}/${dockerImageName}:\${dockerImageTag}"
        `;
      default:
        return `
          echo "Pushing Docker image to registry..."
          withCredentials([
            usernamePassword(
              credentialsId: 'docker-registry-credentials',
              usernameVariable: 'DOCKER_USERNAME',
              passwordVariable: 'DOCKER_PASSWORD'
            )
          ]) {
            sh "echo \${DOCKER_PASSWORD} | docker login -u \${DOCKER_USERNAME} --password-stdin"
            sh "docker tag \${DOCKER_IMAGE} \${DOCKER_USERNAME}/${dockerImageName}:\${dockerImageTag}"
            sh "docker push \${DOCKER_USERNAME}/${dockerImageName}:\${dockerImageTag}"
            env.DOCKER_IMAGE = "\${DOCKER_USERNAME}/${dockerImageName}:\${dockerImageTag}"
          }
        `;
    }
  }
}
